#ifndef UNICODE
#define UNICODE
#endif

#include <windows.h>


LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);


/*
    Parameters:
     - hInstance: instance handler of the program tha contains program necessary information
     - hPrevInstance: intuitive but legacy stuff and should be zero
     - pCmdLine: a pointer to a wide string that contains the command line arguments
     - nCmdShow: an integer with flags that contain information about how to show the window
*/
int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, PWSTR pCmdLine, int nCmdShow)
{
    //Register c++ window class

    const wchar_t w_class_name[] = L"Sample Window Class";

    WNDCLASS wc = {};

    wc.lpfnWndProc = WindowProc;
    wc.hInstance = hInstance;
    wc.lpszClassName = w_class_name;

    RegisterClass(&wc);

    //Creating the window

    HWND hwnd = CreateWindowEx(
        0,                          //Optional window styles
        w_class_name,               //Previously registered (in a class package) class name
        L"My first window",         //The window title (name)
        WS_OVERLAPPEDWINDOW,        //Window style

        //Size and position
        CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, 

        NULL,                       //Parent window
        NULL,                       //Menu (any?)
        hInstance,                  //Instance handle (of this program)
        NULL                        //Additional application paramteters
    );

    if(!hwnd) return 0;

    ShowWindow(hwnd, nCmdShow); //Show the window and detail show flags

    //Run the message loop 
    //The shown window receives messages from the user input

    MSG msg = {};

    //WM_QUIT is generated by PostQuitMessage and is the only message that makes GetMessage to return zero
    while(GetMessage(&msg, NULL, 0, 0) > 0)
    {
        TranslateMessage(&msg); //This is basically to remove the header from the message
        DispatchMessage(&msg);
    }

    return 0;
}


/*
    The window procedure, describes how the window responds to events

    wParam + lParam (extra information from the message, depends on the message code)
*/
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    //WM -> Window Message
    switch(uMsg)
    {
    case WM_DESTROY:        //You can also WM_DESTOY a window but not to destroy the program itself
        PostQuitMessage(0);
        break;
    case WM_PAINT: // Says that a window portion needs to be painted because it is visible
        PAINTSTRUCT window_painter;
        HDC hdc = BeginPaint(hwnd, &window_painter); //HDC -> Handle Device Control

        //All painting operations between BeginPaint and EndPaint

        //Fill rectangle (rcPaint is the rectangle struct with screen coordinates)
        FillRect(hdc, &window_painter.rcPaint, (HBRUSH) (COLOR_WINDOW+1));

        EndPaint(hwnd, &window_painter);
    }

    //Default message handling
    /*
        IMPORTANT:
        This is for handling default window messages and system window messages that the 
        application is not gonig to manage.
        
        It calls the Default Window Procedure to handle System and some user messages
    */
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}


/*
    NOTE:
    The optimum painting code would be that just automatically paints the visible window region 
    instead of relying on the operating system window manager to ignore the painted portions 
    when other windows are overlapped
*/

/*
    NOTE:
    The system notifies the program with WM_MESSAGE when a part of a window needs to be painted because
    there is no window shadowing that rectangle
*/